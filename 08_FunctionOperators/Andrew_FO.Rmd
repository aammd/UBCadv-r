---
title: "Andrew_FOs"
author: "Andrew MacDonald"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: yes
    keep_md: TRUE
---

```{r opts}
knitr::opts_chunk$set(error = TRUE, cache = TRUE)
library(ggplot2)
library(tidyr)
library(magrittr)
```

## Write a FO that logs a time stamp and message to a file every time a function is run.

```{r}
write_time <- function(timefile = "time.txt", f) {
  force(f)
  function(...) {
    now <- as.character(Sys.time())
    write(now,file = timefile)
    f(...)
  }
}

write_time(f = runif)(1)

```

## What does the following function do? What would be a good name for it?

This function saves its answer the first time and always returns that result, even if inputs change.  I'd call it `first_impression`

## modify delay_by

```{r}
library(lubridate)
delay_by2 <- function(delay, f) {
  force(f)
  runtime <- 0 
  dt <- as.numeric(Sys.time() - runtime)
  if(dt < delay) {
    function(...) {
      Sys.sleep(delay)
      f(...)
      runtime <<- Sys.time()
      }
    } else {
      function(...) {
       f(...)
       }
    }
}

g <- delay_by2(1, f = rnorm); g(100); Sys.sleep(2); g(100)
```

## Write wait_until() which delays execution until a specific time.

## There are three places we could have added a memoise call: why did we choose the one we did?
I guess if you memoised the innermost one, you would just be remembering the URLS, and if you memoised the outermost one you'd be saving the execution of the whole expression, which gets you nowhere

```{r}
# microbenchmark(list = list(
#   dot_every(10, memoise(delay_by(1, rnorm)))(100),
#   memoise(dot_every(10, delay_by(1, rnorm)))(100),
#   dot_every(10, delay_by(1, memoise(rnorm)))(100)
#      ))

```


## Why is the remember() function inefficient? How could you implement it in more efficient way?
Because recopies the list every time the function is rerun.  You could add an argument for the NUMBER of things you want to remember and then allocate space for them in your list.

## Why does the following code, from stackoverflow, not do what you expect? 

Because the closures don't remember all the different values, just the final one. you need to add `force()`

******



### Create a negative() FO that flips the sign of the output of the function to which it is applied.

```{r}
negative <- function(f){
  force(f)
  function(...)  -f(...)
}

negative(log)(40)

negative(min)(-5:2)
```


## The evaluate package makes it easy to capture all the outputs (results, text, messages, warnings, errors, and plots) from an expression. Create a function like capture_it() that also captures the warnings and errors generated by a function.

shamelessly stealing from [this answer](http://stackoverflow.com/a/3904728)

```{r}
capture_all <- function(f){
  force(f)
  function(...) {
    out <- list()
    out$ouput <- capture.output(f(...))
    out$error <- tryCatch(f(...),error = function(e) e)
    out$warnin <- tryCatch(f(...),warning = function(w) w)
    out
    }
  }

capture_all(log)(-3)

```


## Create a FO that tracks files created or deleted in the working directory (Hint: use dir() and setdiff().) What other global effects of functions might you want to track?

```{r}
big_brother <- function(f){
  force(f)
  function(...){
    before <- dir(recursive = TRUE)
    f(...)
    after <- dir(recursive = TRUE)
    created <- setdiff(after, before)
    paste0("you just made ", paste(created, collapse = ", "))
  }
}


big_brother(write_time(f = runif))(1)

```

useful also: tracking changes in the global environment? though ideally that wouldn't happen

*****



## Our previous download() function only downloads a single file. How can you use partial() and lapply() to create a function that downloads multiple files at once? What are the pros and cons of using partial() vs. writing a function by hand?

```{r}
download_file <- function(url, ...) {
  download.file(url, basename(url), ...)
}
lapply(urls, download_file)

delay_by <- function(delay, f) {
  function(...) {
    Sys.sleep(delay)
    f(...)
  }
}

dot_every <- function(n, f) {
  i <- 1
  function(...) {
    if (i %% n == 0) cat(".")
    i <<- i + 1
    f(...)
  }
}

lapply(urls, dot_every(10, delay_by(1, download_file)))
```


## Read the source code for plyr::colwise(). How does the code work? What are colwise()’s three main tasks? How could you make colwise() simpler by implementing each task as a function operator? (Hint: think about partial().)

```{r}
#plyr::colwise
function (.fun, .cols = true, ...) 
{
    if (!is.function(.cols)) {
        .cols <- as.quoted(.cols)
        filter <- function(df) eval.quoted(.cols, df)
        # extracts .cols from df, whicch is not yet known
    }
    else {
        filter <- function(df) Filter(.cols, df) 
        # applies predicate to columns of df, not yet known
    }
    dots <- list(...)
    function(df, ...) {
        stopifnot(is.data.frame(df))
        df <- strip_splits(df)
        filtered <- filter(df)       # take the filtered df
        if (length(filtered) == 0) 
            return(data.frame())
        out <- do.call("lapply", c(list(filtered, .fun, ...), 
            dots))
        ## previous line is the heart of it. Does lapply on the filtered data, applying .fun, with all the dots past and present
        names(out) <- names(filtered)
        quickdf(out)
    }
}

```

* determine if the data frame is to be filtered by name or by predicate
* filter it
* use lapply to run a function over those columns

*do it via partial?*

## Write FOs that convert a function to return a matrix instead of a data frame, or a data frame instead of a matrix. If you understand S3, call them as.data.frame.function() and as.matrix.function().

```{r}
as.df.fn <- function(f){
  function(...){
    as.data.frame(f(...))
  }
}

as.df.fn(matrix)(1:9, nrow = 3)


as.mat.fn <- function(f){
  function(...){
    as.matrix(f(...))
  }
}

obj <- as.mat.fn(data.frame)(one = 1:9, two = rnorm(9))
class(obj)
obj
```

so, why was knowledge of S3 required??


## You’ve seen five functions that modify a function to change its output from one form to another. What are they? Draw a table of the various combinations of types of outputs: what should go in the rows and what should go in the columns? What function operators might you want to write to fill in the missing cells? Come up with example use cases.

I can't think of any of these, other than `Negate`

`base::Negate()`
`plyr::failwith()` 
`capture_it()`
`time_it()`


## Look at all the examples of using an anonymous function to partially apply a function in this and the previous chapter. Replace the anonymous function with partial(). What do you think of the result? Is it easier or harder to read?

```{r}
ignore <- function(...) NULL
tee <- function(f, on_input = ignore, on_output = ignore) {
  function(...) {
    on_input(...)
    output <- f(...)
    on_output(output)
    output
  }
}

g <- function(x) cos(x) - x
zero <- uniroot(g, c(-5, 5))
show_x <- function(x, ...) cat(sprintf("%+.08f", x), "\n")

library(pryr)

partial(uniroot, interval = c(-5, 5))(g)

format_it <- partial(sprintf, "%+.08f")

newline <- partial(cat, "\n")

show_x2 <- function(x) newline(format_it(x))
zero <- uniroot(tee(g, on_output = show_x2), c(-5, 5))
```

**previous chapter**:

```{r}
trims <- c(0, 0.1, 0.2, 0.5)
x <- rcauchy(1000)
sapply(trims, function(trim) mean(x, trim = trim))
# this seems a bit dirty -- relies on knowing "trim" is 2nd arg
sapply(trims, partial(mean, x = x))
```

```{r}
boot_df <- function(x) x[sample(nrow(x), rep = T), ]
replace_samp <- partial(sample, replace = TRUE)
boot_df2 <- function(x) x[replace_samp(nrow(x)), ]
#boot_df2(iris)

`s[` <- partial(`[`,i = replace_samp(nrow(x)))
`s[`

disp = function(x) x * 0.0163871
disp2 <- partial(`*`,y = 0.0163871)
disp2(1)

am = function(x) factor(x, levels = c("auto", "manual"))
am <- partial(factor, levels = c("auto", "manual"))
am(c("auto","auto"))

```



*****

## Implement your own version of compose() using Reduce and %o%. For bonus points, do it without calling function.

```{r}
"%o%" <- compose
compose2 <- partial(Reduce, f = `%o%`)
compose2(c(mean,exp,sqrt))(1:10)

mean(exp(sqrt(1:10)))

(mean %o% exp %o% sqrt)(1:10)

```


## Extend and() and or() to deal with any number of input functions. Can you do it with Reduce()? Can you keep them lazy (e.g., for and(), the function returns once it sees the first FALSE)?

```{r}
and <- function(...) {
  lapply(list(...), force)
  fs <- lapply(list(...), match.fun)
  function(x) {
    results <- lapply(fs, function(f) f(x))
    Reduce(`&&`,results)
  }
}

and(is.numeric,is.integer,is.vector)(2L)

and(is.numeric,is.integer,is.vector,is.na)(2L)


```


## Implement the xor() binary operator. Implement it using the existing xor() function. Implement it as a combination of and() and or(). What are the advantages and disadvantages of each approach? Also think about what you’ll call the resulting function to avoid a clash with the existing xor() function, and how you might change the names of and(), not(), and or() to keep them consistent.

```{r}
`%xor%` <- function(x, y) xor(x, y) 

TRUE %xor% FALSE

and <- function(f1, f2) {
  force(f1); force(f2)
  function(...) {
    f1(...) && f2(...)
  }
}

or <- function(f1, f2) {
  force(f1); force(f2)
  function(...) {
    f1(...) || f2(...)
  }
}



```



## Above, we implemented boolean algebra for functions that return a logical function. Implement elementary algebra (plus(), minus(), multiply(), divide(), exponentiate(), log()) for functions that return numeric vectors.

```{r}
maker <- function(f){
  force(f)
  function(...) {
    lapply(list(...), force)
    fs <- lapply(list(...), match.fun)
    function(x) {
      results <- lapply(fs, function(f) f(x))
      Reduce(f,results)
      }
    }
}

add_em <- maker(`+`)
unenclose(add_em)

add_em(rnorm,rnorm)(1)

heres_yer_functions <- list(plus = `+`,
                            minus = `-`,
                            multiply = `*`,
                            divide = `/`,
                            exponentiate = `^`)

yer_functions_are_done <- lapply(heres_yer_functions,maker)

yer_functions_are_done$plus(rnorm,rnorm)(1)
yer_functions_are_done$divide(rnorm,rnorm)(1)

```

