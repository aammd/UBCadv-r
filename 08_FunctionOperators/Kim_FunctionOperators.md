---
Title: "Functional Operators"
Author: "Kim"
Date: '2014-10-07'
---

***

### Chapter Notes

A function operator is a function that takes one (or more) functions as input and returns a function as output

- behavioral FOs change the behavior of a function, e.g. ensuring that a function only runs once
- output FOs manipulate the output of a function, e.g. capturing errors
- input FOs modify the inputs to a function, e.g. `vectorize()` or `partial`
- combining FOs use function composition and logical operations to combine multiple functions

best to make the function the last argument of the function wrapping it

memoisation: modify a function to automatically cache its results - from library(memoise) 
A memoised function can run much faster because it stores all of the previous inputs and outputs, using more memory




***
### Exercises 1

1.  Write a FO that logs a time stamp and message to a file every time a 
    function is run.
    ```
    log_time <- function(message, f) {
  	t <- Sys.time()
  	m <- message
  	f(...) 
  	write.table(c(message, t), file="log.txt")
	}
    ```

1.  What does the following function do? What would be a good name for it?

    ```{r}
    f <- function(g) {
      force(g)
      result <- NULL
      function(...) {
        if (is.null(result)) {
          result <<- g(...)
        }
        result
      }
    }
    runif2 <- f(runif)
    runif2(5)
    runif2(10)
    ```
    **makes the given number of randomly generated numbers, stores them and onyl gives them back as the answer anytime the function 
    is run again. a good name might be store_randoms()**

1.  Modify `delay_by()` so that instead of delaying by a fixed amount of time, 
    it ensures that a certain amount of time has elapsed since the function 
    was last called. That is, if you called 
    `g <- delay_by(1, f); g(); Sys.sleep(2); g()` there shouldn't be an 
    extra delay.
	
	**I interpret this as asking that there is no additional delay besides that called by Sys.sleep(2)? 
	Not sure if I've done this one right, but my thought was to have the delay not be within the function, 
	but before the function is called within the FO?**
	```
	delay_by <- function(delay, f) {
    Sys.sleep(delay)
	  function(...) {
	    f(...)
	  }
	}
	```
	
1.  Write `wait_until()` which delays execution until a specific time.
	```
	wait_until <- function(delay, f) {
    if(Sys.time==delay){
	  function(...) {
	    f(...)
	  }}
	}
	```

1.  There are three places we could have added a memoise call: why did we 
    choose the one we did?
    
    **I guess he wants to say how each of these is diff, not why we chose the one we did in the chapter text above?**

    ```{r, eval = FALSE}
    download <- memoise(dot_every(10, delay_by(1, download_file))) **does this one only save the file name every 10 iterations?**
    download <- dot_every(10, memoise(delay_by(1, download_file))) **this was the one we want, I think because it saves the file name each time, after the delay has happened as well**
    download <- dot_every(10, delay_by(1, memoise(download_file))) **not sure what was wrong with this one?**
    ```

1.  Why is the `remember()` function inefficient? How could you implement it 
    in more efficient way?
    
    **because it assignes the function output to an object each time and stores that in new memory appended to the 
    memory also being used? Not sure what the fix is?**

1.  Why does the following code, from 
    [stackoverflow](http://stackoverflow.com/questions/8440675), not do what you expect?

    ```{r}
    # return a linear function with slope a and intercept b.
    f <- function(a, b) function(x) a * x + b

    # create a list of functions with different parameters.
    fs <- Map(f, a = c(0, 1), b = c(0, 1))

    fs[[1]](3)
    # should return 0 * 3 + 0 = 0
    ```
    **I wasn't expecting it to return 0. I think this is lazy evaluation? 
    Need to force the a and b values for the first iteration of f?**

    How can you modify `f` so that it works correctly?


### Exercises 2

1.  Create a `negative()` FO that flips the sign of the output of the 
    function to which it is applied.
    
    ```
    change_sign <- function(x){
    	force(x)
    	function(...) (-1)*x(...)
    }
    ```
    **kind of working from Hadley's `Negate()` function here, but not sure if I've done it right**

1.  The `evaluate` package makes it easy to capture all the outputs (results, 
    text, messages, warnings, errors, and plots) from an expression. Create a 
    function like `capture_it()` that also captures the warnings and errors 
    generated by a function.

1.  Create a FO that tracks files created or deleted in the working directory 
    (Hint: use `dir()` and `setdiff()`.) What other global effects of 
    functions might you want to track?
    

### Exercises 3

1.  Our previous `download()` function only downloads a single file. How can 
    you use `partial()` and `lapply()` to create a function that downloads 
    multiple files at once? What are the pros and cons of using `partial()` vs. 
    writing a function by hand?

1.  Read the source code for `plyr::colwise()`. How does the code work? What 
    are `colwise()`'s three main tasks? How could you make `colwise()` simpler 
    by implementing each task as a function operator? (Hint: think about 
    `partial()`.)

1.  Write FOs that convert a function to return a matrix instead of a data 
    frame, or a data frame instead of a matrix. If you understand S3, 
    call them `as.data.frame.function()` and `as.matrix.function()`.

1.  You've seen five functions that modify a function to change its output 
    from one form to another. What are they? Draw a table of the various 
    combinations of types of outputs: what should go in the rows and what 
    should go in the columns? What function operators might you want to write 
    to fill in the missing cells? Come up with example use cases.

1.  Look at all the examples of using an anonymous function to partially 
    apply a function in this and the previous chapter. Replace the anonymous 
    function with `partial()`. What do you think of the result? Is it easier or 
    harder to read?



### Exercises 4

1.  Implement your own version of `compose()` using `Reduce` and `%o%`. For 
    bonus points, do it without calling `function`.

1.  Extend `and()` and `or()` to deal with any number of input functions. Can 
    you do it with `Reduce()`? Can you keep them lazy (e.g., for `and()`, the 
    function returns once it sees the first `FALSE`)?

1.  Implement the `xor()` binary operator. Implement it using the existing 
    `xor()` function. Implement it as a combination of `and()` and `or()`. What 
    are the advantages and disadvantages of each approach? Also think about 
    what you'll call the resulting function to avoid a clash with the existing
    `xor()` function, and how you might change the names of `and()`, `not()`, 
    and `or()` to keep them consistent.

1.  Above, we implemented boolean algebra for functions that return a logical 
    function. Implement elementary algebra (`plus()`, `minus()`, `multiply()`, 
    `divide()`, `exponentiate()`, `log()`) for functions that return numeric 
    vectors.