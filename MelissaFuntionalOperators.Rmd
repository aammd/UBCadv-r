---
title: "Functional Operators"
author: "Melissa"
date: "October 6, 2014"
output: html_document
---

#### memoising for population models. 


```{r setup, include = FALSE, cache = FALSE}
knitr::opts_chunk$set(error = TRUE)
```

library("memoise")
library("plyr")
library("pryr")


**Behavioral Operators**

1. Write a FO that logs a time stamp and message to a file every time a function is run.

```{r}

stamp<-function(f){
  function(...){
    write(c(Sys.time(),'Hello there'), file='hello')
  f(...)
  } 
}

```

2. What does the following function do? What would be a good name for it?

```{r}
f <- function(g) {
  force(g)
  result <- NULL
  function(...) {
    if (is.null(result)) {
      result <<- g(...)
    }
    result
  }
}
runif2 <- f(runif)
runif2(5)
#> [1] 0.3750332 0.4502083 0.7858626 0.1851057 0.9658681
runif2(10)
#> [1] 0.3750332 0.4502083 0.7858626 0.1851057 0.9658681
```

It forces the first call of result outside of the function environment so that result is always the same? maybe first result. 

3. Modify delay_by() so that instead of delaying by a fixed amount of time, it ensures that a certain amount of time has elapsed since the function was last called. That is, if you called g <- delay_by(1, f); g(); Sys.sleep(2); g() there shouldn’t be an extra delay.

```{r}
delay_by <- function(delay, f) {
  function(...) {
    Sys.sleep(delay)
    f(...)
  }
}
```

Somehow force the delay?

4. Write wait_until() which delays execution until a specific time.

```{r}
wait_until <- function(time, f) {
  force(f)
  function(...) {
    tstart<-Sys.time()
    tdif<-tstart-time
    Sys.sleep(tdif)
    f(...)
  }
}
```

5. There are three places we could have added a memoise call: why did we choose the one we did?

download <- memoise(dot_every(10, delay_by(1, download_file)))
download <- dot_every(10, memoise(delay_by(1, download_file)))
download <- dot_every(10, delay_by(1, memoise(download_file)))



6. Why is the remember() function inefficient? How could you implement it in more efficient way?

```{r}
remember <- function() {
  memory <- list()
  f <- function(...) {
    # This is inefficient!
    memory <- append(memory, list(...))
    assign("memory", append(memory, list(...)), envir=globalenv())
    invisible()
  }

  structure(f, class = "remember")
}
```
Because it searches over all the environments for memory 

7. Why does the following code, from stackoverflow, not do what you expect?

# return a linear function with slope a and intercept b.
f <- function(a, b) function(x) a * x + b

# create a list of functions with different parameters.
fs <- Map(f, a = c(0, 1), b = c(0, 1))

fs[[1]](3)
#> [1] 4
# should return 0 * 3 + 0 = 0
How can you modify f so that it works correctly?

```{r}
f <- function(a, b) {
  force(c(a,b))
  function(x) a * x + b
}
  
fs <- Map(f, a = c(0, 1), b = c(0, 1))
fs[[1]](3)
```

```{r}
tee <- function(f, on_input = ignore, on_output = ignore) {
  function(...) {
    on_input(...)
    output <- f(...)
    on_output(output)
    output
  }
}

show_x <- function(x, ...) cat(sprintf("%+.08f", x), "\n")

tee(fs[[1]](),show_x)

```


**Output Operators**

1. Create a negative() FO that flips the sign of the output of the function to which it is applied.

```{r}
negative <- function(f) {
  force(f)
  function(...) -1*f(...)
}
```

2. The evaluate package makes it easy to capture all the outputs (results, text, messages, warnings, errors, and plots) from an expression. Create a function like capture_it() that also captures the warnings and errors generated by a function.

```{r}
capture_it <- function(f) {
  force(f)
  function(...) {
    evaluate()
  }
}

```


3. Create a FO that tracks files created or deleted in the working directory (Hint: use dir() and setdiff().) What other global effects of functions might you want to track?

```{r}
negative <- function(f) {
  force(f)
  function(...) {
    d1<-dir()
    f(...)
    difd1<-setdiff(dir(), d1)
  } 
}
```



** Input FOs**

1. Our previous download() function only downloads a single file. How can you use partial() and lapply() to create a function that downloads multiple files at once? What are the pros and cons of using partial() vs. writing a function by hand?

```{r}
download_file <- function(url, ...) {
  download.file(url, basename(url), ...)
}


multiple_download<-function(){
  lapply(urls, partial(download_file))
}


```


2. Read the source code for plyr::colwise(). How does the code work? What are colwise()’s three main tasks? How could you make colwise() simpler by implementing each task as a function operator? (Hint: think about partial().)

colwise

3. Write FOs that convert a function to return a matrix instead of a data frame, or a data frame instead of a matrix. If you understand S3, call them as.data.frame.function() and as.matrix.function().

```{r}
as.matrix.function<-function(f){
  force(f)
  function(...) 
}

```


4. You’ve seen five functions that modify a function to change its output from one form to another. What are they? Draw a table of the various combinations of types of outputs: what should go in the rows and what should go in the columns? What function operators might you want to write to fill in the missing cells? Come up with example use cases.

5. Look at all the examples of using an anonymous function to partially apply a function in this and the previous chapter. Replace the anonymous function with partial(). What do you think of the result? Is it easier or harder to read?








